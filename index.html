<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mesh Story â€” Image Lock</title>

<style>
  html, body {
    margin: 0;
    background: #000;
  }
  body {
    display: flex;
    justify-content: center;
    padding: 40px;
  }
  canvas {
    width: 360px;          /* preview scale */
    height: auto;
    background: #000;
    border: 2px solid #222;
  }
</style>
</head>

<body>

<canvas id="c" width="1080" height="1920"></canvas>

<script>
/* =====================================================
   CONFIG
===================================================== */

// CSV source (public)
const CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTavGvSojxM1vYpMv0FSoC-WzIK3IqTYPNl1SYbya4iV8VJUaEmHso7yghmGQPLJvwpsEMzKjbonPDz/pub?output=csv";

// mesh overlay (local file in repo)
const MESH_SRC = "./meshvertstory.png";

/* =====================================================
   CANVAS + LAYOUT
===================================================== */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// hero placement (LOCK THESE VISUALLY)
const HERO = {
  x: 180,
  y: 420,
  size: 720,
  radius: 64
};

// mesh placement (LOCK THESE VISUALLY)
const MESH = {
  x: 120,
  y: 260,
  height: 1400
};

/* =====================================================
   HELPERS
===================================================== */

function loadImage(src) {
  return new Promise(resolve => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => resolve(null);
    img.src = src;
  });
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

function drawHero(ctx, img, cfg) {
  ctx.save();
  roundRect(ctx, cfg.x, cfg.y, cfg.size, cfg.size, cfg.radius);
  ctx.clip();

  const scale = Math.max(
    cfg.size / img.width,
    cfg.size / img.height
  );

  ctx.drawImage(
    img,
    cfg.x + (cfg.size - img.width * scale) / 2,
    cfg.y + (cfg.size - img.height * scale) / 2,
    img.width * scale,
    img.height * scale
  );

  ctx.restore();
}

function parseCSV(text) {
  const rows = [];
  let row = [], field = "", inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i], n = text[i + 1];
    if (c === '"' && inQuotes && n === '"') {
      field += '"'; i++;
    } else if (c === '"') {
      inQuotes = !inQuotes;
    } else if (c === "," && !inQuotes) {
      row.push(field); field = "";
    } else if (c === "\n" && !inQuotes) {
      row.push(field);
      rows.push(row);
      row = []; field = "";
    } else {
      field += c;
    }
  }
  if (field) { row.push(field); rows.push(row); }
  return rows;
}

/* =====================================================
   MAIN
===================================================== */

async function render() {
  // background
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, 1080, 1920);

  // load CSV
  const csvText = await fetch(CSV_URL, { cache: "no-store" }).then(r => r.text());
  const rows = parseCSV(csvText);
  const headers = rows.shift();

  // map rows
  const data = rows.map(r => {
    const o = {};
    headers.forEach((h, i) => o[h] = r[i] || "");
    return o;
  });

  // take FIRST row with an Image URL
  const row = data.find(r => r["Image URL"]);
  if (!row) return;

  // load images
  const heroImg = await loadImage(row["Image URL"]);
  const meshImg = await loadImage(MESH_SRC);

  // draw hero
  if (heroImg) {
    drawHero(ctx, heroImg, HERO);
  }

  // draw mesh OVER hero
  if (meshImg) {
    const scale = MESH.height / meshImg.height;
    ctx.drawImage(
      meshImg,
      MESH.x,
      MESH.y,
      meshImg.width * scale,
      meshImg.height * scale
    );
  }
}

render();
</script>

</body>
</html>
