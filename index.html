<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mesh Story â€” Anchored Auto-Width Pill</title>

<style>
  html, body { margin:0; background:#000; }
  body { display:flex; justify-content:center; padding:40px; }
  canvas{
    width:360px;
    height:auto;
    background:#000;
    border:2px solid #222;
  }
</style>
</head>

<body>

<canvas id="c" width="1080" height="1920"></canvas>

<script>
/* =====================================================
   CONFIG
===================================================== */

const CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTavGvSojxM1vYpMv0FSoC-WzIK3IqTYPNl1SYbya4iV8VJUaEmHso7yghmGQPLJvwpsEMzKjbonPDz/pub?output=csv";

const OVERLAY_SRC = "./meshvertstory.png";

/* =====================================================
   CANVAS
===================================================== */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

/* =====================================================
   HERO (LOCKED)
===================================================== */
const HERO = {
  x: 260,
  y: 500,
  size: 650,
  radius: 64
};

/* =====================================================
   TIME (LOCKED â€” NOT IN PILL)
===================================================== */
const TIME = {
  offsetX: -160,
  offsetY: 8,
  size: 38,
  weight: 600
};

/* =====================================================
   TEXT STYLES (PILL ONLY)
===================================================== */
const SHOW = {
  baseSize: 58,
  weight: 700,
  color: "#000",
  lineGap: 2
};

const META = {
  baseSize: 48,
  weight: 500,
  color: "#333",
  lineGap: 6
};

/* =====================================================
   PILL â€” HARD ANCHOR + AUTO WIDTH
===================================================== */
const PILL = {
  // ðŸ”’ HARD ANCHOR (top-left corner of pill)
  offsetX: 45,
  offsetY: 54,

  // text scaling only
  scale: 0.72,

  // padding
  padX: 22,
  padY: 18,

  // gap between show + meta
  gap: 10,

  radius: 8
};

/* =====================================================
   HELPERS
===================================================== */
function loadImage(src) {
  return new Promise(resolve => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => resolve(null);
    img.src = src;
  });
}

function parseCSV(text) {
  const rows = [];
  let row = [], field = "", inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i], n = text[i + 1];
    if (c === '"' && inQuotes && n === '"') { field += '"'; i++; }
    else if (c === '"') { inQuotes = !inQuotes; }
    else if (c === "," && !inQuotes) { row.push(field); field = ""; }
    else if (c === "\n" && !inQuotes) { row.push(field); rows.push(row); row = []; field = ""; }
    else { field += c; }
  }
  if (field) { row.push(field); rows.push(row); }
  return rows.map(r => r.map(v => (v ?? "").trim()));
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

function drawRoundedCover(ctx, img, x, y, size, r) {
  ctx.save();
  roundRect(ctx, x, y, size, size, r);
  ctx.clip();

  const scale = Math.max(size / img.width, size / img.height);
  const w = img.width * scale;
  const h = img.height * scale;

  ctx.drawImage(
    img,
    x + (size - w) / 2,
    y + (size - h) / 2,
    w,
    h
  );

  ctx.restore();
}

/* =====================================================
   TIME FORMAT
===================================================== */
function formatTime(t) {
  let [h, m] = t.split(":").map(Number);
  const ampm = h >= 12 ? "pm" : "am";
  h = h % 12 || 12;
  return m ? `${h}:${String(m).padStart(2,"0")}${ampm}` : `${h}${ampm}`;
}

function formatTimeRange(range) {
  if (!range || !range.includes("-")) return range;
  const [start, end] = range.split("-").map(s => s.trim());
  return `${formatTime(start)}â€“${formatTime(end)}`;
}

/* =====================================================
   TEXT WRAP
===================================================== */
function wrapText(ctx, text, maxWidth) {
  const words = (text || "").split(/\s+/).filter(Boolean);
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? line + " " + w : w;
    if (ctx.measureText(test).width <= maxWidth) {
      line = test;
    } else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);
  return lines;
}

/* =====================================================
   MAIN
===================================================== */
async function render() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, 1080, 1920);

  const csvText = await fetch(CSV_URL, { cache: "no-store" }).then(r => r.text());
  const rows = parseCSV(csvText);
  const headers = rows.shift();

  const data = rows.map(r => {
    const o = {};
    headers.forEach((h, i) => o[h] = r[i] || "");
    return o;
  });

  const row = data.find(r => r["Image URL"]);
  if (!row) return;

  const heroImg = await loadImage(row["Image URL"]);
  const overlayImg = await loadImage(OVERLAY_SRC);

  // HERO
  if (heroImg) {
    drawRoundedCover(ctx, heroImg, HERO.x, HERO.y, HERO.size, HERO.radius);
  }

  const baseY = HERO.y + HERO.size;

  /* ===== TIME (UNCHANGED) ===== */
  const timeText = formatTimeRange(row["A-B"]);
  if (timeText) {
    ctx.fillStyle = "#fff";
    ctx.font = `${TIME.weight} ${TIME.size}px Inter, system-ui, sans-serif`;
    const w = ctx.measureText(timeText).width;
    ctx.fillText(
      timeText,
      HERO.x + HERO.size / 2 - w / 2 + TIME.offsetX,
      baseY + TIME.offsetY
    );
  }

  /* ===== PILL (HARD ANCHORED) ===== */
  const pillX = HERO.x + PILL.offsetX;
  const pillY = baseY + PILL.offsetY;

  const scale = PILL.scale;
  const showSize = SHOW.baseSize * scale;
  const metaSize = META.baseSize * scale;

  const showText = row["Now Playing"] || "";
  const metaText = [
    row["DJ"],
    row["Guest DJ"] ? `ðŸŽ§ ${row["Guest DJ"]}` : "",
    row["Guest MC"] ? `ðŸŽ¤ ${row["Guest MC"]}` : ""
  ].filter(Boolean).join("  +  ");

  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  // measure + wrap
  ctx.font = `${SHOW.weight} ${showSize}px Inter, system-ui, sans-serif`;
  const showLines = wrapText(ctx, showText, 1000);

  ctx.font = `${META.weight} ${metaSize}px Inter, system-ui, sans-serif`;
  const metaLines = wrapText(ctx, metaText, 1000);

  // longest line width
  let textW = 0;
  for (const l of [...showLines, ...metaLines]) {
    textW = Math.max(textW, ctx.measureText(l).width);
  }

  const pillW = textW + PILL.padX * 2;

  const showBlockH = showLines.length * (showSize + SHOW.lineGap);
  const metaBlockH = metaLines.length * (metaSize + META.lineGap);
  const pillH =
    showBlockH +
    (metaText ? PILL.gap + metaBlockH : 0) +
    PILL.padY * 2;

  // pill bg
  ctx.fillStyle = "#fff";
  roundRect(ctx, pillX, pillY, pillW, pillH, PILL.radius);
  ctx.fill();

  let y = pillY + PILL.padY;

  // show text
  ctx.fillStyle = SHOW.color;
  ctx.font = `${SHOW.weight} ${showSize}px Inter, system-ui, sans-serif`;
  for (const line of showLines) {
    ctx.fillText(line, pillX + PILL.padX, y);
    y += showSize + SHOW.lineGap;
  }

  // meta text
  if (metaText) {
    y += PILL.gap;
    ctx.fillStyle = META.color;
    ctx.font = `${META.weight} ${metaSize}px Inter, system-ui, sans-serif`;
    for (const line of metaLines) {
      ctx.fillText(line, pillX + PILL.padX, y);
      y += metaSize + META.lineGap;
    }
  }

  // overlay
  if (overlayImg) ctx.drawImage(overlayImg, 0, 0);
}

render();
</script>

</body>
</html>
